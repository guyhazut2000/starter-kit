---
description: Environment configurations, deployment strategies, and dev/stage/test/prod setup
globs: ["**/*"]
alwaysApply: true
---

# Environment and Deployment

## Environment Types

### Development

- **Purpose**: Local development
- **Database**: Local PostgreSQL or SQLite
- **Logging**: Console + file logging, verbose
- **Error Handling**: Detailed error messages
- **Caching**: Minimal or disabled
- **Hot Reload**: Enabled

### Staging

- **Purpose**: Pre-production testing
- **Database**: Staging database (separate from production)
- **Logging**: Structured logging, info level
- **Error Handling**: User-friendly messages, detailed logs
- **Caching**: Enabled with shorter TTL
- **Monitoring**: Full monitoring enabled

### Test

- **Purpose**: Automated testing
- **Database**: Test database (can be reset)
- **Logging**: Minimal logging
- **Error Handling**: Standard error handling
- **Caching**: Disabled or minimal
- **Isolation**: Each test run is isolated

### Production

- **Purpose**: Live application
- **Database**: Production database (backed up)
- **Logging**: Structured logging, error level
- **Error Handling**: User-friendly messages only
- **Caching**: Fully enabled with appropriate TTL
- **Monitoring**: Full monitoring and alerting

## Environment Variables

### Development (`.env.local`)

```env
# Database
DATABASE_URL="postgresql://user:password@localhost:5432/dbname_dev"

# Next.js
NODE_ENV="development"
NEXT_PUBLIC_APP_URL="http://localhost:3000"

# Logging
LOG_LEVEL="debug"

# Feature Flags
ENABLE_FEATURE_X="true"
ENABLE_DEBUG_MODE="true"

# API Keys (development keys)
API_KEY="dev-api-key"
```

### Staging (`.env.staging`)

```env
# Database
DATABASE_URL="postgresql://user:password@staging-db:5432/dbname_staging"

# Next.js
NODE_ENV="production"
NEXT_PUBLIC_APP_URL="https://staging.example.com"

# Logging
LOG_LEVEL="info"

# Feature Flags
ENABLE_FEATURE_X="true"
ENABLE_DEBUG_MODE="false"

# API Keys (staging keys)
API_KEY="staging-api-key"
```

### Production (`.env.production`)

```env
# Database
DATABASE_URL="postgresql://user:password@prod-db:5432/dbname_prod"

# Next.js
NODE_ENV="production"
NEXT_PUBLIC_APP_URL="https://example.com"

# Logging
LOG_LEVEL="error"

# Feature Flags
ENABLE_FEATURE_X="false"
ENABLE_DEBUG_MODE="false"

# API Keys (production keys)
API_KEY="prod-api-key"
```

### Test (`.env.test`)

```env
# Database
DATABASE_URL="postgresql://user:password@localhost:5432/dbname_test"

# Next.js
NODE_ENV="test"
NEXT_PUBLIC_APP_URL="http://localhost:3000"

# Logging
LOG_LEVEL="error"

# Feature Flags
ENABLE_FEATURE_X="false"
ENABLE_DEBUG_MODE="false"
```

## Environment Variable Naming

### Rules

- **UPPER_SNAKE_CASE**: All environment variables
- **NEXT*PUBLIC*\***: Prefix for client-accessible variables
- **Descriptive names**: Clear purpose from name
- **Grouped by purpose**: Database, API, Feature Flags, etc.

### Client vs Server Variables

**Server-only** (no `NEXT_PUBLIC_` prefix):

- Database URLs
- API keys and secrets
- Internal service URLs
- Server configuration

**Client-accessible** (`NEXT_PUBLIC_` prefix):

- Public API URLs
- Public feature flags
- Analytics IDs
- Public configuration

## Deployment Strategy

### Development

**Local Development:**

```bash
# Start development server
npm run dev

# Run on specific port
npm run dev -- -p 3001

# Watch for changes
# Hot reload enabled automatically
```

**Requirements:**

- Local database running
- Environment variables in `.env.local`
- Node.js 20+ installed
- All dependencies installed

### Staging

**Deployment Process:**

1. Merge to `main` branch
2. CI/CD pipeline runs tests
3. Build application
4. Deploy to staging environment
5. Run smoke tests
6. Notify team of deployment

**Verification:**

- Check application loads
- Verify database connections
- Test critical user flows
- Check logs for errors

### Production

**Deployment Process:**

1. Code reviewed and approved
2. All tests pass
3. Staging deployment verified
4. Production deployment (automated or manual)
5. Health checks run
6. Monitor for issues
7. Rollback plan ready

**Pre-Deployment Checklist:**

- [ ] All tests pass
- [ ] Code reviewed and approved
- [ ] Database migrations tested
- [ ] Environment variables configured
- [ ] Feature flags set correctly
- [ ] Monitoring configured
- [ ] Rollback plan ready
- [ ] Team notified

**Post-Deployment:**

- [ ] Verify application is running
- [ ] Check error logs
- [ ] Monitor performance metrics
- [ ] Test critical user flows
- [ ] Verify database connections

## Database Migrations

### Development

```bash
# Create migration
npx prisma migrate dev --name migration_name

# Migration automatically applied
# Prisma Client regenerated
```

### Staging/Production

```bash
# Apply migrations (does not create new migrations)
npx prisma migrate deploy

# Verify migration status
npx prisma migrate status
```

### Migration Best Practices

- **Always test migrations** in development first
- **Review migration SQL** before applying
- **Backup database** before production migrations
- **Apply migrations** during deployment
- **Monitor** for migration issues
- **Have rollback plan** ready

## Logging Configuration

### Development

```typescript
// Verbose logging
logger.level = "debug";
logger.add(
  new winston.transports.Console({
    format: winston.format.simple(),
  })
);
```

### Staging

```typescript
// Info level logging
logger.level = "info";
logger.add(
  new winston.transports.File({
    filename: "app.log",
  })
);
```

### Production

```typescript
// Error level logging
logger.level = "error";
logger.add(
  new winston.transports.File({
    filename: "error.log",
    level: "error",
  })
);
logger.add(
  new winston.transports.File({
    filename: "combined.log",
  })
);
```

## Caching Strategy by Environment

### Development

- Minimal caching
- Fast refresh for development
- Cache invalidation on every change

### Staging

- Moderate caching
- Shorter TTL (1-5 minutes)
- Cache invalidation after deployments

### Production

- Full caching enabled
- Appropriate TTL based on data freshness
- Cache invalidation via revalidation

## Error Handling by Environment

### Development

- Detailed error messages
- Stack traces shown
- Helpful debugging information

### Staging

- User-friendly messages
- Detailed logs for debugging
- Error tracking enabled

### Production

- User-friendly messages only
- No technical details exposed
- Errors logged for monitoring
- Error tracking and alerting

## Monitoring and Observability

### Metrics to Monitor

**Application:**

- Response times
- Error rates
- Request counts
- Memory usage
- CPU usage

**Database:**

- Query performance
- Connection pool usage
- Migration status
- Database size

**Infrastructure:**

- Server health
- Network latency
- Disk usage
- SSL certificate status

### Alerting

**Critical Alerts:**

- Application down
- Database connection failures
- High error rates
- Security incidents

**Warning Alerts:**

- High response times
- Approaching resource limits
- Unusual traffic patterns

## Rollback Procedures

### Quick Rollback

1. Identify last known good deployment
2. Revert to previous version
3. Verify application is working
4. Investigate issue
5. Fix and redeploy

### Database Rollback

1. **Never rollback migrations** that have been applied to production
2. Create new migration to fix issues
3. Test migration in staging first
4. Apply fix migration to production

### Rollback Checklist

- [ ] Identify issue
- [ ] Determine rollback necessity
- [ ] Notify team
- [ ] Execute rollback
- [ ] Verify application
- [ ] Document issue
- [ ] Plan fix

## Security Considerations

### Environment-Specific

**Development:**

- Use development API keys
- Local database (not production data)
- Debug mode can be enabled

**Staging:**

- Use staging API keys
- Separate staging database
- No production data
- Can test security features

**Production:**

- Use production API keys (securely stored)
- Production database (backed up)
- No debug information exposed
- Full security measures enabled

### Secrets Management

- **Never commit** `.env` files
- Use **environment-specific** secrets
- Rotate secrets **regularly**
- Use **secret management** services in production
- Limit **access** to production secrets

## Health Checks

### Application Health

```typescript
// app/api/health/route.ts
export async function GET() {
  try {
    // Check database connection
    await prisma.$queryRaw`SELECT 1`;

    return Response.json(
      { status: "healthy", timestamp: new Date().toISOString() },
      { status: 200 }
    );
  } catch (error) {
    return Response.json(
      { status: "unhealthy", error: "Database connection failed" },
      { status: 503 }
    );
  }
}
```

### Monitoring Endpoints

- `/api/health` - Application health
- `/api/health/db` - Database health
- `/api/metrics` - Application metrics (if configured)

## Best Practices

### DO

- ✅ Use environment-specific configurations
- ✅ Never commit `.env` files
- ✅ Use `.env.example` as template
- ✅ Validate environment variables on startup
- ✅ Use secret management in production
- ✅ Monitor application health
- ✅ Have rollback procedures ready
- ✅ Test deployments in staging first

### DON'T

- ❌ Commit secrets to version control
- ❌ Use production secrets in development
- ❌ Skip environment variable validation
- ❌ Deploy without testing
- ❌ Skip database backups
- ❌ Ignore monitoring alerts
- ❌ Deploy on Fridays (unless critical)
